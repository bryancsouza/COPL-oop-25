---
path: '/part-16/5-the-either-type'
title: 'The Either type'
hidden: false
---

<text-box variant='learningObjectives' name="Learning objectives">

After this section

</text-box>


Sometimes it would be nice if you could add an error message or something to `Nothing`. That’s why we have the `Either` type. The `Either` type takes two type arguments. The type `Either a b` has two constructors: `Left` and `Right`. Both take an argument, `Left` an argument of type `a` and `Right` an argument of type `b`.

|Type|Values|
|------|------|
|`Either Int Bool`|`Left 0`, `Left 1`, `Right False`, `Right True`, …|
|`Either String [Int]`|`Left "asdf"`, `Right [0,1,2]`, …|
|`Either Integer Integer`|`Left 0`, `Right 0`, `Left 1`, `Right 1`, …|

Here’s a simple example: a `readInt` function that only knows a couple of numbers and returns a descriptive error for the rest. Note the Haskell convention of using `Left` for errors and `Right` for success.

```haskell
readInt :: String -> Either String Int
readInt "0" = Right 0
readInt "1" = Right 1
readInt s = Left ("Unsupported string: " ++ s)
```

Sidenote: the constructors of `Either` are called `Left` and `Right` because they refer to the left and right type arguments of `Either`. Note how in `Either a b`, `a` is the left argument and `b` is the right argument. Thus `Left` contains a value of type `a` and likewise `Right` of type `b`. The convention of using `Right` for success is probably simply because right also means correct. No offense is intended to left-handed people.

Here’s another example: pattern matching an `Either`. Just like with `Maybe`, there are two patterns for an `Either`, one for each constructor.

```haskell
iWantAString :: Either Int String -> String
iWantAString (Right str)   = str
iWantAString (Left number) = show number
```

As you recall, Haskell lists can only contain elements of the same type. You can’t have a value like `[1,"foo",2]`. However, you can use a type like `Either` to represent lists that can contain two different types of values. For example we could track the number of people on a lecture, with a possibility of adding an explanation if a value is missing:

```haskell
lectureParticipants :: [Either String Int]
lectureParticipants = [Right 10, Right 13, Left "easter vacation", Right 17, Left "lecturer was sick", Right 3]
```
