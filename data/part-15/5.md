---
path: '/part-15/5-working-with-examples'
title: 'Working with examples'
hidden: false
---

<text-box variant='learningObjectives' name="Learning objectives">
In the following section, we will see

* How do definitions in Haskell work?

</text-box>


When you see an example definition like this

```haskell
polynomial :: Double -> Double
polynomial x = x^2 - x - 1
```
you should usually play around with it. Start by running it. There are a couple of ways to do this.

If a definition fits on one line, you can just define it in GHCi:
```haskell
Prelude> polynomial x = x^2 - x - 1
Prelude> polynomial 3.0
5.0
```

For a multi-line definition, you can either use `;` to separate lines, or use the special `:{ :}` syntax to paste a block of code into GHCi:

```haskell
Prelude> :{
Prelude| polynomial :: Double -> Double
Prelude| polynomial x = x^2 - x - 1
Prelude| :}
Prelude> polynomial 3.0
5.0
```
Finally, you can paste the code into a new or existing `.hs` file, and then `:load` it into GHCi. If the file has already been loaded, you can also use `:reload`.

    -- first copy and paste the definition into Example.hs, then run GHCi
    Prelude> :load Example.hs
    [1 of 1] Compiling Main             ( Example.hs, interpreted )
    Ok, one module loaded.
    *Main> polynomial 3.0
    5.0
    -- now you can edit the definition
    *Main> :reload
    [1 of 1] Compiling Main             ( Example.hs, interpreted )
    Ok, one module loaded.
    *Main> polynomial 3
    3.0

After you’ve run the example, try modifying it, or making another function that is similar but different. You learn programming by programming, not by reading!

### 1.8.1 Dealing with Errors

Since Haskell is a typed language, you’ll pretty quickly bump into type errors. Here’s an example of an error during a GHCi session:

```Haskell
Prelude> "string" ++ True

<interactive>:1:13: error:
    • Couldn't match expected type ‘[Char]’ with actual type ‘Bool’
    • In the second argument of ‘(++)’, namely ‘True’
        In the expression: "string" ++ True
        In an equation for ‘it’: it = "string" ++ True
```

This is the most common type error, “Couldn’t match expected type”. Even though the error looks long and scary, it’s pretty simple if you just read through it.

*   The first line of the error message, `<interactive>:1:13: error:` tells us that the error occurred in GHCi. If we had loaded a file, we might instead get something like `Sandbox.hs:3:17: error:`, where `Sandbox.hs` is the name of the file, `3` is the line number and `17` is the number of a character in the line.

*   The line `• Couldn't match expected type ‘[Char]’ with actual type ‘Bool’` tells us that the immediate cause for the error is that there was an expression of type `Bool`, when GHCi was expecting to find an expression of type `[Char]`“. The location of this error was indicated in the first line of the error message. Note that the expected type is not always right. Giving type annotations by hand can help debugging typing errors.

*   The line `• In the second argument of ‘(++)’, namely ‘True’` tells that the expression that had the wrong type was the second argument of the operator `(++)`. We’ll learn later why it’s surrounded by parentheses.

*   The full expression with the error was `"string" ++ True`. As mentioned above, `String` is a type alias for `[Char]`, the type of character lists. The first argument to `++` was a list of characters, and since `++` can only combine two lists of the same type, the second argument should’ve been of type `[Char]` too.

*   The line `In an equation for ‘it’: it = "string" ++ True` says that the expression occurred in the definition of the variable `it`, which is a default variable name that GHCi uses for standalone expressions. If we had a line `x = "string" ++ True` in a file, or a declaration `let x = "string" ++ True` in GHCi, GHCi would print `In an equation for ‘x’: x = "string" ++ True` instead.


There are also others types of errors.
```Haskell
Prelude> True + 1

<interactive>:6:1: error:
    • No instance for (Num Bool) arising from a use of ‘+’
    • In the expression: True + 1
        In an equation for ‘it’: it = True + 1
```
This is the kind of error you get when you try to use a numeric function like `+` on something that’s not a number.

The hardest error to track down is usually this:

```Haskell
    Prelude> True +

    <interactive>:10:7: error:
        parse error (possibly incorrect indentation or mismatched brackets)
```
There are many ways to cause it. Probably you’re missing some characters somewhere. We’ll get back to indentation later in this lecture.

### 1.8.2 Arithmetic

There’s one thing in Haskell arithmetic that often trips up beginners, and that’s division.

In Haskell there are two division functions, the `/` operator and the `div` function. The `div` function does integer division:
```Haskell
Prelude> 7 `div` 2
3
```
The `/` operator performs the usual division:
```Haskell
Prelude> 7.0 / 2.0
3.5
```
However, you can only use `div` on whole number types like `Int` and `Integer`, and you can only use `/` on decimal types like `Double`. Here’s an example of what happens if you try to mix them up:
```Haskell
halve :: Int -> Int
halve x = x / 2

error:
    • No instance for (Fractional Int) arising from a use of ‘/’
    • In the expression: x / 2
        In an equation for ‘halve’: halve x = x / 2
```

Just try to keep this in mind for now. We’ll get back to the difference between `/` and `div`, and what `Num` and `Fractional` mean when talking about type classes.





<text-box variant='exercise' name="Exercise 1.1">

```Haskell
-- Ex 1: define variables one and two. They should have type Int and
-- values 1 and 2, respectively.
```
</text-box>

<text-box variant='exercise' name="Exercise 1.3">

```Haskell
-- Ex 2: define the function double of type Integer->Integer. Double
-- should take one argument and return it multiplied by two.

double :: Integer -> Integer
double x = todo
```
</text-box>
<text-box variant='exercise' name="Exercise 1.4">

```Haskell

-- Ex 3: define the function quadruple that uses the function double
-- from the previous exercise to return its argument multiplied by
-- four.

quadruple :: Integer -> Integer
quadruple x = todo
```
</text-box>
<text-box variant='exercise' name="Exercise 1.2">

```Haskell

-- Ex 4: define the function distance. It should take four arguments of
-- type Double: x1, y1, x2, and y2 and return the (euclidean) distance
-- between points (x1,y1) and (x2,y2).
--
-- Give distance a type signature, i.e. distance :: something.
--
-- PS. if you can't remember how the distance is computed, the formula is:
--   square root of ((x distance) squared + (y distance) squared)
--
-- Examples:
--   distance 0 0 1 1  ==>  1.4142135...
--   distance 1 1 4 5  ==>  5.0

distance = todo

```

</text-box>
