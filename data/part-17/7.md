---
path: '/part-17/7-quiz'
title: 'Quiz + common errors'
hidden: false
---


<p>What’s the type of this function? <code>both p q x = p x &amp;&amp; q x</code></p>
<ol className="quiz-list">
<click-quiz>
<code>a -&gt; Bool -&gt; a -&gt; Bool -&gt; a -&gt; Bool</code>
</click-quiz>
<click-quiz correct>
<code>(a -&gt; Bool) -&gt; (a -&gt; Bool) -&gt; a -&gt; Bool</code>
</click-quiz>
<click-quiz>
<code>(a -&gt; Bool) -&gt; (b -&gt; Bool) -&gt; c -&gt; Bool</code>
</click-quiz>
</ol>
<p>What’s the (most general) type of this function? <code>applyInOut f g x = f (g (f x))</code></p>
<ol className="quiz-list">
<click-quiz correct>
<code>(a -&gt; b) -&gt; (b -&gt; a) -&gt; a -&gt; b</code>
</click-quiz>
<click-quiz>
<code>(a -&gt; b) -&gt; (b -&gt; c) -&gt; a -&gt; c</code>
</click-quiz>
<click-quiz>
<code>(a -&gt; a) -&gt; (a -&gt; a) -&gt; a -&gt; a</code>
</click-quiz>
</ol>
<p>Which one of the following functions adds its first argument to the second?</p>
<ol className="quiz-list">
<click-quiz>
<code>f x x = x + x</code>
</click-quiz>
<click-quiz correct>
<code>f x = \y -&gt; x + y</code>
</click-quiz>
<click-quiz>
<code>f = \x y -&gt; x + x</code>
</click-quiz>
</ol>
<p>Which one of the following functions does not satisfy <code>f 1 ==&gt; 1</code>?</p>
<ol className="quiz-list">
<click-quiz>
<code>f x = (\y -&gt; y) x</code>
</click-quiz>
<click-quiz correct>
<code>f x = \y -&gt; y</code>
</click-quiz>
<click-quiz>
<code>f x = (\y -&gt; x) x</code>
</click-quiz>
</ol>
<p>Which one of the following functions is correctly typed?</p>
<ol className="quiz-list">
<click-quiz>
<code>f x y = not x; f :: (Bool -&gt; Bool) -&gt; Bool</code>
</click-quiz>
<click-quiz>
<code>f x = x ++ "a"; f :: Char -&gt; String</code>
</click-quiz>
<click-quiz correct>
<code>f x = 'a' : x; f :: String -&gt; String</code>
</click-quiz>
</ol>
<p>How many arguments does <code>drop 2</code> take?</p>
<ol className="quiz-list">
<click-quiz>
Zero
</click-quiz>
<click-quiz correct>
One
</click-quiz>
<click-quiz>
Two
</click-quiz>
</ol>



<p>What does this function do? <code>f (_: x:_) = x</code></p>
<ol className="quiz-list">
<click-quiz>
Returns the first element of a list
</click-quiz>
<click-quiz>
Returns an arbitrary element of a list
</click-quiz>
<click-quiz>
Returns all except the first and last elements of a list
</click-quiz>
<click-quiz correct>
Returns the second element of a list
</click-quiz>
</ol>



<p>What is the result of <code>reverse $ take 5 . tail $ "This is a test"</code>?</p>
<ol className="quiz-list">
<click-quiz correct>
<code>"i sih"</code>
</click-quiz>
<click-quiz>
<code>"set a"</code>
</click-quiz>
<click-quiz>
A type error
</click-quiz>
</ol>


<p>If <code>f :: a -&gt; b</code>, then what is the type of <code>map (.f)</code>?</p>
<ol className="quiz-list">
<click-quiz correct>
<code>[b -&gt; c] -&gt; [a -&gt; c]</code>
</click-quiz>
<click-quiz>
<code>[c -&gt; a] -&gt; [c -&gt; b]</code>
</click-quiz>
<click-quiz>
<code>(b -&gt; c) -&gt; [a -&gt; c]</code>
</click-quiz>
<click-quiz>
<code>[a] -&gt; [b]</code>
</click-quiz>
</ol>


<p>What is the type of the leftmost <code>id</code> in <code>id id</code>?</p>
<ol className="quiz-list">
<click-quiz>
unspecified
</click-quiz>


<click-quiz>
<code>a</code></a>
</click-quiz>

<click-quiz>
<code>a -&gt; a</code>
</click-quiz>
<click-quiz correct>
<code>(a -&gt; a) -&gt; (a -&gt; a)</code>
</click-quiz>
</ol>
<p>What is the type of <code>const const</code>?</p>
<ol className="quiz-list">
<click-quiz>
unspecified
</click-quiz>
<click-quiz>
<code>(c -&gt; a -&gt; b) -&gt; a</code>
</click-quiz>
<click-quiz correct>
<code>c -&gt; (a -&gt; b -&gt; a)</code>
</click-quiz>
<click-quiz>
<code>a -&gt; b -&gt; c -&gt; a</code>
</click-quiz>
</ol>



*   [Set3a](https://github.com/moocfi/haskell-mooc/blob/master/exercises/Set3a.hs): normal list exercises
*   [Set3b](https://github.com/moocfi/haskell-mooc/blob/master/exercises/Set3b.hs): list recursion exercises

### Common Errors
```haskell
No instance for (Eq a) arising from a use of ‘==’
```
You’ve probably tried to use `x==Nothing` to check if a value is `Nothing`. Use pattern matching instead. The reason for this error is that values of type `Maybe a` can’t be compared because Haskell doesn’t know how to compare values of the polymorphic type `a`. You’ll find more about this in the next lecture. Use pattern matching instead of `==` for now.
